<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TooN: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TooN&#160;<span id="projectnumber">2.0.0-beta8</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">TooN Documentation</div>  </div>
</div>
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="sIntro"></a>
Introduction</h2>
<p>The TooN library is a set of C++ header files which provide basic numerics facilities:</p>
<ul>
<li><a class="el" href="structTooN_1_1Vector.html">Vectors</a>, <a class="el" href="structTooN_1_1Matrix.html">matrices</a> and <a class="el" href="group__gLinAlg.html">etc </a></li>
<li><a class="el" href="group__gDecomps.html">Matrix decompositions</a></li>
<li><a class="el" href="group__gOptimize.html">Function optimization</a></li>
<li><a class="el" href="group__gTransforms.html">Parameterized matrices (eg transformations)</a></li>
<li><a class="el" href="group__gEquations.html">linear equations</a></li>
<li><a class="el" href="group__gFunctions.html">Functions (eg numerical derivatives) </a></li>
</ul>
<p>It provides classes for statically- (known at compile time) and dynamically- (unknown at compile time) sized vectors and matrices and it can delegate advanced functions (like large SVD or multiplication of large matrices) to LAPACK and BLAS (this means you will need libblas and liblapack).</p>
<p>The library makes substantial internal use of templates to achieve run-time speed efficiency whilst retaining a clear programming syntax.</p>
<p>Why use this library?</p>
<ul>
<li>Because it supports statically sized vectors and matrices very efficiently.</li>
<li>Because it provides extensive type safety for statically sized vectors and matrices (you can't attempt to multiply a 3x4 matrix and a 2-vector).</li>
<li>Because it supports transposition, subscripting and slicing of matrices (to obtain a vector) very efficiently.</li>
<li>Because it interfaces well to other libraries.</li>
<li>Because it exploits LAPACK and BLAS (for which optimised versions exist on many platforms).</li>
<li>Because it is fast, <a class="el" href="sCramerIsBad.html">but not at the expense of numerical stability. </a></li>
</ul>
<h2><a class="anchor" id="sUsage"></a>
How to use TooN</h2>
<p>This section is arranged as a FAQ. Most answers include code fragments. Assume <code>using namespace <a class="el" href="namespaceTooN.html" title="Everything lives inside this namespace.">TooN</a>;</code>.</p>
<ul>
<li><a class="el" href="index.html#sDownload">Getting the code and installing</a></li>
<li><a class="el" href="index.html#sStart">Getting started</a></li>
<li><a class="el" href="index.html#sWindowsErrors">Comilation errors on Win32 involving TOON_TYPEOF</a></li>
<li><a class="el" href="index.html#sCreateVector">How do I create a vector?</a></li>
<li><a class="el" href="index.html#sCreateMatrix">How do I create a matrix?</a></li>
<li><a class="el" href="index.html#sFunctionVector">How do I write a function taking a vector?</a></li>
<li><a class="el" href="index.html#sGenericCode">How do I write generic code?</a></li>
<li><a class="el" href="index.html#sConst">What is wrong with constness?</a></li>
<li><a class="el" href="index.html#sElemOps">What elementary operations are supported?</a></li>
<li><a class="el" href="index.html#sInitialize">How I initialize a vector/matrix?</a></li>
<li><a class="el" href="index.html#sScalars">How do I add a scalar to every element of a vector/matrix?</a></li>
<li><a class="el" href="index.html#ssExamples">Are there any examples?</a></li>
<li><a class="el" href="index.html#sSTL">How do I store Dynamic vectors in STL containers.</a></li>
<li><a class="el" href="index.html#sResize">How do I resize a dynamic vector/matrix?</a></li>
<li><a class="el" href="index.html#sDebug">What debugging options are there?</a></li>
<li><a class="el" href="index.html#sSlices">What are slices?</a></li>
<li><a class="el" href="index.html#sFuncSlices">How do I return a slice from a function?</a></li>
<li><a class="el" href="index.html#sPrecision">Can I have a precision other than double?</a></li>
<li><a class="el" href="index.html#sSolveLinear">How do I invert a matrix / solve linear equations?</a></li>
<li><a class="el" href="index.html#sOtherStuff">What other stuff is there:</a></li>
<li><a class="el" href="index.html#sHandyFuncs">What handy functions are there (normalize, identity, fill, etc...)?</a></li>
<li><a class="el" href="index.html#sNoInplace">Why don't functions work in place?</a></li>
<li><a class="el" href="index.html#sColMajor">Can I have a column major matrix?</a></li>
<li><a class="el" href="index.html#sWrap">I have a pointer to a bunch of data. How do I turn it in to a vector/matrix without copying?</a></li>
<li><a class="el" href="index.html#sWrap">How do I interface to other libraries?</a></li>
<li><a class="el" href="index.html#sImplementation">How is it implemented</a></li>
</ul>
<h3><a class="anchor" id="sDownload"></a>
Getting the code and installing</h3>
<p>To get the code from cvs use:</p>
<p>cvs -z3 -d:pserver:<a href="mailto:anoncvs@cvs.savannah.nongnu.org">anoncvs@cvs.savannah.nongnu.org</a>:/cvsroot/toon co <a class="el" href="namespaceTooN.html" title="Everything lives inside this namespace.">TooN</a></p>
<p>The home page for the library with a version of this documentation is at:</p>
<p><a href="http://mi.eng.cam.ac.uk/~er258/cvd/toon.html">http://mi.eng.cam.ac.uk/~er258/cvd/toon.html</a></p>
<p>The code will work as-is, and comes with a default configuration, which should work on any system.</p>
<p>On a unix system, <code>./configure &amp;&amp; make install </code> will install <a class="el" href="namespaceTooN.html" title="Everything lives inside this namespace.">TooN</a> to the correct place. Note there is no code to be compiled, but the configure script performs some basic checks.</p>
<p>On non-unix systems, e.g. Windows and embedded systems, you may wish to configure the library manually. See <a class="el" href="index.html#sManualConfiguration">Manual configuration</a>.</p>
<h3><a class="anchor" id="sStart"></a>
Getting started</h3>
<p>To begin, just in include the right <a href="file:">file:</a></p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">        #include &lt;TooN/TooN.h&gt;</span>
</pre></div><p>Everything lives in the <code><a class="el" href="namespaceTooN.html" title="Everything lives inside this namespace.">TooN</a></code> namespace.</p>
<p>Then, make sure the directory containing <a class="el" href="namespaceTooN.html" title="Everything lives inside this namespace.">TooN</a> is in your compiler's search path. If you use any decompositions, you will need to link against LAPACK, BLAS and any required support libraries. On a modern unix system, linking against LAPACK will do this automatically.</p>
<h3><a class="anchor" id="sWindowsErrors"></a>
Comilation errors on Win32 involving TOON_TYPEOF</h3>
<p>If you get errors compiling code that uses <a class="el" href="namespaceTooN.html" title="Everything lives inside this namespace.">TooN</a>, look for the macro TOON_TYPEOF in the messages. Most likely the file <code><a class="el" href="config_8hh_source.html">internal/config.hh</a></code> is clobbered. Open it and remove all the defines present there.</p>
<p>Also see <a class="el" href="index.html#sManualConfiguration">Manual configuration</a> for more details on configuring <a class="el" href="namespaceTooN.html" title="Everything lives inside this namespace.">TooN</a>, and <a class="el" href="index.html#sConfigLapack">Functions using LAPACK</a>, if you want to use LAPACK and BLAS. Define the macro in <code><a class="el" href="config_8hh_source.html">internal/config.hh</a></code>.</p>
<h3><a class="anchor" id="sCreateVector"></a>
How do I create a vector?</h3>
<p>Vectors can be statically sized or dynamically sized.</p>
<div class="fragment"><pre class="fragment">            Vector&lt;3&gt; v1;    <span class="comment">//Create a static sized vector of size 3</span>
            Vector&lt;&gt;  v2(4); <span class="comment">//Create a dynamically sized vector of size 4</span>
            Vector&lt;Dynamic&gt;  v2(4); <span class="comment">//Create a dynamically sized vector of size 4</span>
</pre></div><p>See also <a class="el" href="index.html#sPrecision">Can I have a precision other than double?</a>.</p>
<h3><a class="anchor" id="sCreateMatrix"></a>
How do I create a matrix?</h3>
<p>Matrices can be statically sized or dynamically sized.</p>
<div class="fragment"><pre class="fragment">            Matrix&lt;3&gt; m;              <span class="comment">//A 3x3 matrix (statically sized)</span>
            Matrix&lt;3,2&gt;  m;           <span class="comment">//A 3x2 matrix (statically sized)</span>
            Matrix&lt;&gt;  m(5,6);         <span class="comment">//A 5x6 matrix (dynamically sized)</span>
            Matrix&lt;3,Dynamic&gt; m(3,6); <span class="comment">//A 3x6 matrix with a dynamic number of columns and static number of rows.</span>
            Matrix&lt;Dynamic,2&gt; m(3,2); <span class="comment">//A 2x3 matrix with a dynamic number of rows and static number of columns.</span>
</pre></div><p>See also <a class="el" href="index.html#sPrecision">Can I have a precision other than double?</a>.</p>
<h3><a class="anchor" id="sFunctionVector"></a>
How do I write a function taking a vector?</h3>
<p>To write a function taking a local copy of a vector: </p>
<div class="fragment"><pre class="fragment">            <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Size&gt; <span class="keywordtype">void</span> func(Vector&lt;Size&gt; v);
</pre></div><p>To write a function taking any type of vector by reference: </p>
<div class="fragment"><pre class="fragment">        <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Size, <span class="keyword">typename</span> Precision, <span class="keyword">typename</span> Base&gt; <span class="keywordtype">void</span> func(<span class="keyword">const</span> Vector&lt;Size, Precision, Base&gt;&amp; v);
</pre></div><p> See also <a class="el" href="index.html#sPrecision">Can I have a precision other than double?</a>, <a class="el" href="index.html#sGenericCode">How do I write generic code?</a> and <a class="el" href="index.html#sNoInplace">Why don't functions work in place?</a></p>
<p>Slices are strange types. If you want to write a function which uniformly accepts <code>const</code> whole objects as well as slices, you need to template on the precision.</p>
<p>Note that constness in C++ is tricky (see <a class="el" href="index.html#sConst">What is wrong with constness?</a>). If you write the function to accept <code> Vector&lt;3, double, B&gt;&amp; </code>, then you will not be able to pass it slices from <code> const Vector</code>s. If, however you write it to accept <code> Vector&lt;3, const double, B&gt;&amp; </code>, then the only way to pass in a <code>Vector&lt;3&gt;</code> is to use the <code>.as_slice()</code> method.</p>
<p>See also <a class="el" href="index.html#sGenericCode">How do I write generic code?</a></p>
<h3><a class="anchor" id="sConst"></a>
What is wrong with constness?</h3>
<p>In <a class="el" href="namespaceTooN.html" title="Everything lives inside this namespace.">TooN</a>, the behaviour of a Vector or Matrix is controlled by the third template parameter. With one parameter, it owns the data, with another parameter, it is a slice. A static sized object uses the variable: </p>
<div class="fragment"><pre class="fragment">             <span class="keywordtype">double</span> my_data[3];
</pre></div><p> to hold the data. A slice object uses: </p>
<div class="fragment"><pre class="fragment">             <span class="keywordtype">double</span>* my_data;
</pre></div><p> When a Vector is made <code>const</code>, C++ inserts <code>const</code> in to those types. The <code>const</code> it inserts it top level, so these become (respectively): </p>
<div class="fragment"><pre class="fragment">             <span class="keyword">const</span> <span class="keywordtype">double</span> my_data[3];
             <span class="keywordtype">double</span> * <span class="keyword">const</span> my_data;
</pre></div><p> Now the types behave very differently. In the first case <code>my_data[0]</code> is immutable. In the second case, <code>my_data</code> is immutable, but <code>my_data[0]</code> is mutable.</p>
<p>Therefore a slice <code>const Vector</code> behaves like an immutable pointer to mutable data. <a class="el" href="namespaceTooN.html" title="Everything lives inside this namespace.">TooN</a> attempts to make <code>const</code> objects behave as much like pointers to <em>immutable</em> data as possible.</p>
<p>The semantics that <a class="el" href="namespaceTooN.html" title="Everything lives inside this namespace.">TooN</a> tries to enforce can be bypassed with sufficient steps: </p>
<div class="fragment"><pre class="fragment">            <span class="comment">//Make v look immutable</span>
            <span class="keyword">template</span>&lt;<span class="keyword">class</span> P, <span class="keyword">class</span> B&gt; <span class="keywordtype">void</span> fake_immutable(<span class="keyword">const</span> Vector&lt;2, P, B&gt;&amp; v)
            {
                Vector&lt;2, P, B&gt; nonconst_v(v);
                nonconst_v[0] = 0; <span class="comment">//Effectively mutate v</span>
            }

            <span class="keywordtype">void</span> bar()
            {
                Vector&lt;3&gt; v;
                ...
                fake_immutable(v.slice&lt;0,2&gt;());
                <span class="comment">//Now v is mutated</span>
            }
</pre></div><p>See also <a class="el" href="index.html#sFunctionVector">How do I write a function taking a vector?</a></p>
<h3><a class="anchor" id="sElemOps"></a>
What elementary operations are supported?</h3>
<p>Assignments are performed using <code>=</code>. See also <a class="el" href="index.html#sNoResize">Why does assigning mismatched dynamic vectors fail?</a>.</p>
<p>These operators apply to vectors or matrices and scalars. The operator is applied to every element with the scalar. </p>
<div class="fragment"><pre class="fragment">        *=, /=, *, / 
</pre></div><p>Vector and vectors or matrices and matrices: </p>
<div class="fragment"><pre class="fragment">        +, -, +=, -= 
</pre></div><p>Dot product: </p>
<div class="fragment"><pre class="fragment">        Vector * Vector
</pre></div><p>Matrix multiply: </p>
<div class="fragment"><pre class="fragment">        Matrix * Matrix
</pre></div><p>Matrix multiplying a column vector: </p>
<div class="fragment"><pre class="fragment">        Matrix * Vector
</pre></div><p>Row vector multiplying a matrix: </p>
<div class="fragment"><pre class="fragment">        Vector * Matrix
</pre></div><p>3x3 Vector cross product: </p>
<div class="fragment"><pre class="fragment">        Vector&lt;3&gt; ^ Vector&lt;3&gt; 
</pre></div><p>All the functions listed below return slices. The slices are simply references to the original data and can be used as lvalues.</p>
<p>Getting the transpose of a matrix: </p>
<div class="fragment"><pre class="fragment">            Matrix.T()
</pre></div><p>Accessing elements: </p>
<div class="fragment"><pre class="fragment">        Vector[i]     <span class="comment">//get element i</span>
        Matrix(i,j)   <span class="comment">//get element i,j</span>
        Matrix[i]     <span class="comment">//get row i as a vector</span>
        Matrix[i][j]  <span class="comment">//get element i,j</span>
</pre></div><p>Turning vectors in to matrices: </p>
<div class="fragment"><pre class="fragment">        Vector.as_row() <span class="comment">//vector as a 1xN matrix</span>
        Vector.as_col() <span class="comment">//vector as a Nx1 matrix</span>
</pre></div><p>Slicing with a start position and size:</p>
<div class="fragment"><pre class="fragment">        Vector.slice&lt;Start, Length&gt;();                         <span class="comment">//Static slice</span>
        Vector.slice(start, length);                           <span class="comment">//Dynamic slice</span>
        Matrix.slice&lt;RowStart, ColStart, NumRows, NumCols&gt;();  <span class="comment">//Static slice</span>
        Matrix.slice(rowstart, colstart, numrows, numcols);    <span class="comment">//Dynamic slice</span>
</pre></div><p>Slicing diagonals: </p>
<div class="fragment"><pre class="fragment">        Matrix.diagonal_slice();                               <span class="comment">//Get the leading diagonal as a vector.</span>
        Vector.as_diagonal();                                  <span class="comment">//Represent a Vector as a DiagonalMatrix</span>
</pre></div><p>Like other features of <a class="el" href="namespaceTooN.html" title="Everything lives inside this namespace.">TooN</a>, mixed static/dynamic slicing is allowed. For example:</p>
<div class="fragment"><pre class="fragment">        Vector.slice&lt;Dynamic, 2&gt;(3, 2);   <span class="comment">//Slice starting at index 3, of length 2.</span>
</pre></div><p>See also <a class="el" href="index.html#sSlices">What are slices?</a></p>
<h3><a class="anchor" id="sInitialize"></a>
How I initialize a vector/matrix?</h3>
<p>Vectors and matrices start off uninitialized (filled with random garbage). They can be easily filled with zeros, or ones (see also <a class="el" href="group__gLinAlg.html#ga77860358ff27be5f58499f4f6a7edd2f" title="This function is used to add a scalar to every element of a vector or matrix.">TooN::Ones</a>): </p>
<div class="fragment"><pre class="fragment">            Vector&lt;3&gt; v = <a class="code" href="group__gLinAlg.html#ga7e787bcb4af6429e598adfa6e9cc7051" title="This function is used to initialize vectors and matrices to zero.">Zeros</a>;
            Matrix&lt;3&gt; m = <a class="code" href="group__gLinAlg.html#ga7e787bcb4af6429e598adfa6e9cc7051" title="This function is used to initialize vectors and matrices to zero.">Zeros</a>
            Vector&lt;&gt;  v2 = <a class="code" href="group__gLinAlg.html#ga7e787bcb4af6429e598adfa6e9cc7051" title="This function is used to initialize vectors and matrices to zero.">Zeros</a>(2); <span class="comment">//Note in they dynamic case, the size must be specified</span>
            Matrix&lt;&gt;  m2 = <a class="code" href="group__gLinAlg.html#ga7e787bcb4af6429e598adfa6e9cc7051" title="This function is used to initialize vectors and matrices to zero.">Zeros</a>(2,2); <span class="comment">//Note in they dynamic case, the size must be specified</span>
</pre></div><p>Vectors can be filled with makeVector: </p>
<div class="fragment"><pre class="fragment">            Vector&lt;&gt; v = makeVector(2,3,4,5,6);
</pre></div><p>Matrices can be initialized to the identity matrix: </p>
<div class="fragment"><pre class="fragment">            Matrix&lt;2&gt; m = Idendity;
            Matrix&lt;&gt; m2 = <a class="code" href="group__gLinAlg.html#ga738fa6ab6e1ba68370aaa9380fde620c" title="This function is used to add a scalar to the diagonal of a matrix, or to construct matrices...">Identity</a>(3);
</pre></div><p> note that you need to specify the size in the dynamic case.</p>
<p>Matrices can be filled from data in row-major order: </p>
<div class="fragment"><pre class="fragment">            Matrix&lt;3&gt; m = <a class="code" href="group__gLinAlg.html#ga970349714fee11f7806fa87d1872b211" title="Package up the function arguments as some data for filling matrices.">Data</a>(1, 2, 3, 
                               4, 5, 6, 
                               7, 8, 9);
</pre></div><p>A less general, but visually more pleasing syntax can also be used: </p>
<div class="fragment"><pre class="fragment">            Vector&lt;5&gt; v;
            <a class="code" href="group__gLinAlg.html#ga41123cff46759c774f576b0dd4c256c1">Fill</a>(v) = 1,2,3,4,5; 

            Matrix&lt;3,3&gt; m;
            <a class="code" href="group__gLinAlg.html#ga41123cff46759c774f576b0dd4c256c1">Fill</a>(m) = 1, 2, 3, 
                      4, 5, 6, 
                      7, 8, 9;
</pre></div><p> Note that underfilling is a run-time check, since it can not be detected at compile time.</p>
<p>They can also be initialized with data from another source. See also <a class="el" href="index.html#sWrap">I have a pointer to a bunch of data. How do I turn it in to a vector/matrix without copying?</a>.</p>
<h3><a class="anchor" id="sScalars"></a>
How do I add a scalar to every element of a vector/matrix?</h3>
<p>Addition to every element is not an elementary operation in the same way as multiplication by a scalar. It is supported throught the ::Ones object:</p>
<div class="fragment"><pre class="fragment">            Vector&lt;3&gt; a, b;
            ...
            b = a + <a class="code" href="group__gLinAlg.html#ga77860358ff27be5f58499f4f6a7edd2f" title="This function is used to add a scalar to every element of a vector or matrix.">Ones</a>*3;       <span class="comment">// b_i = a_i + 3</span>
            a+= Ones * 3;         <span class="comment">// a_i &lt;- a_i + 3</span>
</pre></div><p>It is supported the same way on Matrix and slices.</p>
<h3><a class="anchor" id="sNoResize"></a>
Why does assigning mismatched dynamic vectors fail?</h3>
<p>Vectors are not generic containers, and dynamic vectors have been designed to have the same semantics as static vectors where possible. Therefore trying to assign a vector of length 2 to a vector of length 3 is an error, so it fails. See also <a class="el" href="index.html#sResize">How do I resize a dynamic vector/matrix?</a></p>
<h3><a class="anchor" id="sSTL"></a>
How do I store Dynamic vectors in STL containers.</h3>
<p>As C++ does not yet support move semantics, you can only safely store static and resizable Vectors in STL containers.</p>
<h3><a class="anchor" id="sResize"></a>
How do I resize a dynamic vector/matrix?</h3>
<p>Do you really want to? If you do, then you have to declare it:</p>
<div class="fragment"><pre class="fragment">         Vector&lt;Resizable&gt; v;
         v.resize(3);
         v = makeVector(1, 2, 3);

         v = makeVector(1, 2); <span class="comment">//resize</span>
         v = <a class="code" href="group__gLinAlg.html#ga77860358ff27be5f58499f4f6a7edd2f" title="This function is used to add a scalar to every element of a vector or matrix.">Ones</a>(5); <span class="comment">//resize</span>
         v = <a class="code" href="group__gLinAlg.html#ga7e787bcb4af6429e598adfa6e9cc7051" title="This function is used to initialize vectors and matrices to zero.">Zeros</a>; <span class="comment">// no resize</span>
</pre></div><p>The policy behind the design of <a class="el" href="namespaceTooN.html" title="Everything lives inside this namespace.">TooN</a> is that it is a linear algebra library, not a generic container library, so resizable Vectors are only created on request. They provide fewer guarantees than other vectors, so errors are likely to be more subtle and harder to track down. One of the main purposes is to be able to store Dynamic vectors of various sizes in STL containers.</p>
<p>Assigning vectors of mismatched sizes will cause an automatic resize. Likewise assigning from entities like Ones with a size specified will cause a resize. Assigning from an entities like Ones with no size specified will not cause a resize.</p>
<p>They can also be resized with an explicit call to .resize(). Resizing is efficient since it is implemented internally with <code>std::vector</code>. Note that upon resize, existing data elements are retained but new data elements are uninitialized.</p>
<p>Currently, resizable matrices are unimplemented. If you want a resizable matrix, you may consider using a <code>std::vector</code>, and accessing it as a <a class="el" href="namespaceTooN.html" title="Everything lives inside this namespace.">TooN</a> object when appropriate. See <a class="el" href="index.html#sWrap">I have a pointer to a bunch of data. How do I turn it in to a vector/matrix without copying?</a>. Also, the speed and complexity of resizable matrices depends on the memory layout, so you may wish to use column major matrices as opposed to the default row major layout.</p>
<h3><a class="anchor" id="sDebug"></a>
What debugging options are there?</h3>
<p>By default, everything which is checked at compile time in the static case is checked at run-time in the dynamic case (with some additions). Checks can be disabled with various macros. Note that the optimizer will usually remove run-time checks on static objects if the test passes.</p>
<p>Bounds are not checked by default. Bounds checking can be enabled by defining the macro <code>TOON_CHECK_BOUNDS</code>. None of these macros change the interface, so debugging code can be freely mixed with optimized code.</p>
<p>The debugging checks can be disabled by defining either of the following macros:</p>
<ul>
<li><code>TOON_NDEBUG</code> </li>
<li><code>NDEBUG</code> </li>
</ul>
<p>Additionally, individual checks can be disabled with the following macros:</p>
<ul>
<li>Static/Dynamic mismatch<ul>
<li>Statically determined functions accept and ignore dynamically specified sizes. Nevertheless, it is an error if they do not match.</li>
<li>Disable with <code>TOON_NDEBUG_MISMATCH</code> </li>
</ul>
</li>
<li>Slices<ul>
<li>Disable with <code>TOON_NDEBUG_SLICE</code> </li>
</ul>
</li>
<li>Size checks (for assignment)<ul>
<li>Disable with <code>TOON_NDEBUG_SIZE</code> </li>
</ul>
</li>
<li>overfilling using Fill<ul>
<li>Disable with <code>TOON_NDEBUG_FILL</code> </li>
</ul>
</li>
<li>underfilling using Fill (run-time check)<ul>
<li>Disable with <code>TOON_NDEBUG_FILL</code> </li>
</ul>
</li>
</ul>
<p>Errors are manifested to a call to <code>std::abort()</code>.</p>
<p><a class="el" href="namespaceTooN.html" title="Everything lives inside this namespace.">TooN</a> does not initialize data in a Vector or Matrix. For debugging purposes the following macros can be defined:</p>
<ul>
<li><code>TOON_INITIALIZE_QNAN</code> or <code>TOON_INITIALIZE_NAN</code> Sets every element of newly defined Vectors or Matrixs to quiet NaN, if it exists, and 0 otherwise. Your code will not compile if you have made a Vector or Matrix of a type which cannot be constructed from a number.</li>
<li><code>TOON_INITIALIZE_SNAN</code> Sets every element of newly defined Vectors or Matrixs to signalling NaN, if it exists, and 0 otherwise.</li>
<li><code>TOON_INITIALIZE_VAL</code> Sets every element of newly defined Vectors or Matrixs to the expansion of this macro.</li>
<li><code>TOON_INITIALIZE_RANDOM</code> Fills up newly defined Vectors and Matrixs with random bytes, to trigger non repeatable behaviour. The random number generator is automatically seeded with a granularity of 1 second. Your code will not compile if you have a Vector or Matrix of a non-POD type.</li>
</ul>
<h3><a class="anchor" id="sSlices"></a>
What are slices?</h3>
<p>Slices are references to data belonging to another vector or matrix. Modifying the data in a slice modifies the original object. Likewise, if the original object changes, the change will be reflected in the slice. Slices can be used as lvalues. For example:</p>
<div class="fragment"><pre class="fragment">        Matrix&lt;3&gt; m = <a class="code" href="group__gLinAlg.html#ga738fa6ab6e1ba68370aaa9380fde620c" title="This function is used to add a scalar to the diagonal of a matrix, or to construct matrices...">Identity</a>;

        m.slice&lt;0,0,2,2&gt;() *= 3; <span class="comment">//Multiply the top-left 2x2 submatrix of m by 3.</span>

        m[2] /=10; <span class="comment">//Divide the third row of M by 10.</span>

        m.T()[2] +=2; <span class="comment">//Add 2 to every element of the second column of M.</span>

        m[1].slice&lt;1,2&gt;() = makeVector(3,4); <span class="comment">//Set m_1,1 to 3 and m_1,2 to 4</span>
        
        m[0][0]=6;
</pre></div><p>Slices are usually strange types. See <a class="el" href="index.html#sFunctionVector">How do I write a function taking a vector?</a></p>
<p>See also </p>
<h3><a class="anchor" id="sPrecision"></a>
Can I have a precision other than double?</h3>
<p>Yes! </p>
<div class="fragment"><pre class="fragment">        Vector&lt;3, float&gt; v;          <span class="comment">//Static sized vector of floats</span>
        Vector&lt;Dynamic, float&gt; v(4); <span class="comment">//Dynamic sized vector of floats</span>
        Vector&lt;Dynamic, std::complex&lt;double&gt; &gt; v(4); <span class="comment">//Dynamic sized vector of complex numbers</span>
</pre></div><p>Likewise for matrix. By default, <a class="el" href="namespaceTooN.html" title="Everything lives inside this namespace.">TooN</a> supports all builtin types and std::complex. Using custom types requires some work. If the custom type understands +,-,*,/ with builtin types, then specialize <a class="el" href="structTooN_1_1IsField.html" title="Is a number a field? ie, +, -, *, / defined.">TooN::IsField</a> on the types.</p>
<p>If the type only understands +,-,*,/ with itself, then specialize TooN::Field on the type.</p>
<p>Note that this is required so that <a class="el" href="namespaceTooN.html" title="Everything lives inside this namespace.">TooN</a> can follow the C++ promotion rules. The result of multiplying a <code>Matrix&lt;double&gt;</code> by a <code>Vector&lt;float&gt;</code> is a <code>Vector&lt;double&gt;</code>.</p>
<h3><a class="anchor" id="sFuncSlices"></a>
How do I return a slice from a function?</h3>
<p>Each vector has a <code>SliceBase</code> type indicating the type of a slice.</p>
<p>They can be slightly tricky to use: </p>
<div class="fragment"><pre class="fragment">        Vector&lt;2, double, Vector&lt;4&gt;::SliceBase&gt; sliceof(Vector&lt;4&gt;&amp; v)
        {
            <span class="keywordflow">return</span> v.slice&lt;1,2&gt;();
        }

        <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> S, <span class="keyword">class</span> P, <span class="keyword">class</span> B&gt;
        Vector&lt;2, P, Vector&lt;S, P, B&gt;::SliceBase&gt; sliceof(Vector&lt;S, P, B&gt;&amp; v)
        {
            <span class="keywordflow">return</span> v.template slice&lt;1,2&gt;();
        }

        <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> S, <span class="keyword">class</span> P, <span class="keyword">class</span> B&gt;
        <span class="keyword">const</span> Vector&lt;2, const P, typename Vector&lt;S, P, B&gt;::ConstSliceBase &gt; foo(<span class="keyword">const</span> Vector&lt;S, P, B&gt;&amp; v)
        {
            <span class="keywordflow">return</span> v.template slice&lt;1,2&gt;();
        }
</pre></div><h3><a class="anchor" id="sSolveLinear"></a>
How do I invert a matrix / solve linear equations?</h3>
<p>You use the decomposition objects (see <a class="el" href="index.html#sDecompos">below</a>), for example to solve Ax=b:</p>
<div class="fragment"><pre class="fragment">    Matrix&lt;3&gt; A;
    A[0]=makeVector(1,2,3);
    A[1]=makeVector(3,2,1);
    A[2]=makeVector(1,0,1);

    Vector&lt;3&gt; b = makeVector (2,3,4);

    <span class="comment">// solve Ax=b using LU</span>
    LU&lt;3&gt; luA(A);
    Vector&lt;3&gt; x1 = luA.backsub(b);

    <span class="comment">// solve Ax=b using SVD</span>
    SVD&lt;3&gt; svdA(A);
    Vector&lt;3&gt; x2 = svdA.backsub(b);
</pre></div><p>Similarly for the other <a class="el" href="index.html#sDecompos">decomposition objects</a></p>
<h3><a class="anchor" id="sDecompos"></a>
Which decomposisions are there?</h3>
<p>For general size matrices (not necessarily square) there are: <a class="el" href="classTooN_1_1LU.html">LU </a>, <a class="el" href="classTooN_1_1SVD.html">SVD </a> and <a class="el" href="group__gDecomps.html#ga8af8145ff9e22a712a97ac4b717bed53" title="Perform Gauss-Jordan reduction on m.">gauss_jordan()</a></p>
<p>For square symmetric matrices there are: <a class="el" href="classTooN_1_1SymEigen.html">SymEigen </a> and <a class="el" href="classTooN_1_1Cholesky.html">Cholesky </a></p>
<p>If all you want to do is solve a single Ax=b then you may want <a class="el" href="group__gEquations.html#gaaa07790d5e8bda259eb708575bc1de8b" title="Return the solution for , given  and .">gaussian_elimination()</a></p>
<h3><a class="anchor" id="sOtherStuff"></a>
What other stuff is there:</h3>
<p>Look at the <a class="el" href="">modules </a>.</p>
<h3><a class="anchor" id="sHandyFuncs"></a>
What handy functions are there (normalize, identity, fill, etc...)?</h3>
<p>See <a class="el" href="group__gLinAlg.html">here </a>.</p>
<h3><a class="anchor" id="sNoInplace"></a>
Why don't functions work in place?</h3>
<p>Consider the function: </p>
<div class="fragment"><pre class="fragment">        <span class="keywordtype">void</span> func(Vector&lt;3&gt;&amp; v);
</pre></div><p> It can accept a <code>Vector&lt;3&gt;</code> by reference, and operate on it in place. A <code>Vector&lt;3&gt;</code> is a type which allocates memory on the stack. A slice merely references memory, and is a subtly different type. To write a function taking any kind of vector (including slices) you can write:</p>
<div class="fragment"><pre class="fragment">        <span class="keyword">template</span>&lt;<span class="keyword">class</span> Base&gt; <span class="keywordtype">void</span> func(Vector&lt;3, double, Base&gt;&amp; v);
</pre></div><p>A slice is a temporary object, and according to the rules of C++, you can't pass a temporary to a function as a non-const reference. <a class="el" href="namespaceTooN.html" title="Everything lives inside this namespace.">TooN</a> provides the <code>.ref()</code> method to escape from this restriction, by returning a reference as a non-temporary. You would then have to write: </p>
<div class="fragment"><pre class="fragment">        Vector&lt;4&gt; v;
        ...
        func(v.slice&lt;0,3&gt;().ref());
</pre></div><p> to get func to accept the slice.</p>
<p>You may also wish to consider writing functions that do not modify structures in place. The <code>unit</code> function of <a class="el" href="namespaceTooN.html" title="Everything lives inside this namespace.">TooN</a> computes a unit vector given an input vector. In the following context, the code: </p>
<div class="fragment"><pre class="fragment">        <span class="comment">//There is some Vector, which may be a slice, etc called v;</span>
        v = <a class="code" href="group__gLinAlg.html#gadd21fe76c0df239289b8d056a91e9723" title="Compute a the unit vector .">unit</a>(v);
</pre></div><p> produces exactly the same compiler output as the hypothetical <code>Normalize(v)</code> which operates in place (for static vectors). Consult the ChangeLog entries dated ``Wed 25 Mar, 2009 20:18:16'' and ``Wed 1 Apr, 2009 16:48:45'' for further discussion.</p>
<h3><a class="anchor" id="sColMajor"></a>
Can I have a column major matrix?</h3>
<p>Yes! </p>
<div class="fragment"><pre class="fragment">        Matrix&lt;3, 3, double, ColMajor&gt; m;          <span class="comment">//3x3 Column major matrix</span>
</pre></div><h3><a class="anchor" id="sWrap"></a>
I have a pointer to a bunch of data. How do I turn it in to a vector/matrix without copying?</h3>
<p>To create a vector use: </p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">double</span> d[]={1,2,3,4};
    Vector&lt;4,double,Reference&gt; v1(d);
    Vector&lt;Dynamic,double,Reference&gt; v2(d,4);
</pre></div><p> Or, a functional form can be used: </p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">double</span> d[]={1,2,3,4};

    wrapVector&lt;4&gt;(d);         <span class="comment">//Returns a Vector&lt;4&gt;</span>
    wrapVector&lt;4,double&gt;(d);  <span class="comment">//Returns a Vector&lt;4&gt;</span>
    
    wrapVector(d,3);          <span class="comment">//Return a Vector&lt;Dynamic&gt; of size 3</span>
    wrapVector&lt;Double&gt;(d,3);  <span class="comment">//Return a Vector&lt;Dynamic&gt; of size 3</span>
</pre></div><p>To crate a matrix use </p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">double</span> d[]={1,2,3,4,5,6};
    Matrix&lt;2,3,double,Reference::RowMajor&gt; m1(d);
    Matrix&lt;2,3,double,Reference::ColMajor&gt; m2(d);
    Matrix&lt;Dynamic, Dynamic, double, Reference::RowMajor&gt; m3(d, 2, 3);
    Matrix&lt;Dynamic, 3, double, Reference::RowMajor&gt; m4(d, 2, 3); <span class="comment">// note two size arguments are required for semi-dynamic matrices</span>
</pre></div><p>See also wrapVector() and <a class="el" href="group__gLinAlg.html#gae9ac83f095744b73971f117576f738d0" title="Wrap external data as a Matrix  As usual, if template sizes are provided, then the run-time size is o...">wrapMatrix()</a>.</p>
<h3><a class="anchor" id="sGenericCode"></a>
How do I write generic code?</h3>
<p>The constructors for <a class="el" href="namespaceTooN.html" title="Everything lives inside this namespace.">TooN</a> objects are very permissive in that they accept run-time size arguments for statically sized objects, and then discard the values, This allows you to easily write generic code which works for both static and dynamic inputs.</p>
<p>Here is a function which mixes up a vector with a random matrix: </p>
<div class="fragment"><pre class="fragment">    <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Size, <span class="keyword">class</span> Precision, <span class="keyword">class</span> Base&gt; Vector&lt;Size, Precision&gt; mixup(<span class="keyword">const</span> Vector&lt;Size, Precision, Base&gt;&amp; v)
    {
        <span class="comment">//Create a square matrix, of the same size as v. If v is of dynamic</span>
        <span class="comment">//size, then Size == Dynamic, and so Matrix will also be dynamic. In</span>
        <span class="comment">//this case, TooN will use the constructor arguments to select the</span>
        <span class="comment">//matrix size. If Size is a real size, then TooN will simply ighore</span>
        <span class="comment">//the constructor values.</span>

        Matrix&lt;Size, Size, Precision&gt; m(v.size(), v.size());
        
        <span class="comment">//Fill the matrix with random values that sum up to 1.</span>
        Precision sum=0;
        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i &lt; v.size(); i++)
            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j &lt; v.size(); j++)
                sum += (m[i][j] = rand());
        
        m/= sum;

        <span class="keywordflow">return</span> m * v;
    }
</pre></div><p>Writing functions which safely accept multiple objects requires assertions on the sizes since they may be either static or dynamic. TooN's built in size check will fail at compile time if mismatched static sizes are given, and at run-time if mismatched dynamic sizes are given:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> S1, <span class="keyword">class</span> B1, <span class="keywordtype">int</span> S2, <span class="keyword">class</span> B2&gt; <span class="keywordtype">void</span> func_of_2_vectors(<span class="keyword">const</span> Vector&lt;S1, double, B1&gt;&amp; v1, <span class="keyword">const</span> Vector&lt;S2, double, B2&gt;&amp; v2)
    {
        <span class="comment">//Ensure that vectors are the same size</span>
        SizeMismatch&lt;S1, S2&gt;::test(v1.num_rows(), v2.num_rows());


    }
</pre></div><p>For issues relating to constness, see  and </p>
<h3><a class="anchor" id="ssExamples"></a>
Are there any examples?</h3>
<p>Create two vectors and work out their inner (dot), outer and cross products </p>
<div class="fragment"><pre class="fragment"><span class="comment">// Initialise the vectors</span>
Vector&lt;3&gt; a = makeVector(3,5,0);
Vector&lt;3&gt; b = makeVector(4,1,3);

<span class="comment">// Now work out the products</span>
<span class="keywordtype">double</span> dot = a*b;                            <span class="comment">// Dot product</span>
Matrix&lt;3,3&gt; outer = a.as_col() * b.as_row(); <span class="comment">// Outer product</span>
Vector&lt;3&gt; cross = a ^ b;                     <span class="comment">// Cross product</span>

cout &lt;&lt; <span class="stringliteral">&quot;a:&quot;</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;b:&quot;</span> &lt;&lt; endl &lt;&lt; b &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Outer:&quot;</span> &lt;&lt; endl &lt;&lt; outer &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">&quot;Cross:&quot;</span> &lt;&lt; endl &lt;&lt; cross &lt;&lt; endl;
</pre></div><p>Create a vector and a matrix and multiply the two together </p>
<div class="fragment"><pre class="fragment"><span class="comment">// Initialise a vector</span>
Vector&lt;3&gt; v = makeVector(1,2,3);

<span class="comment">// Initialise a matrix</span>
Matrix&lt;2,3&gt; M(d);
M[0] = makeVector(2,4,5);
M[1] = makeVector(6,8,9);

<span class="comment">// Now perform calculations</span>
Vector&lt;2&gt; v2 = M*v;  <span class="comment">// OK - answer is a static 2D vector</span>
Vector&lt;&gt; v3 = M*v;   <span class="comment">// OK - vector is determined to be 2D at runtime</span>
Vector&lt;&gt; v4 = v*M;   <span class="comment">// Compile error - dimensions of matrix and vector incompatible</span>
</pre></div><h3><a class="anchor" id="sImplementation"></a>
How is it implemented</h3>
<h4><a class="anchor" id="ssStatic"></a>
Static-sized vectors and matrices</h4>
<p>One aspect that makes this library efficient is that when you declare a 3-vector, all you get are 3 doubles - there's no metadata. So <code>sizeof(Vector&lt;3&gt;)</code> is 24. This means that when you write <code>Vector&lt;3&gt; v;</code> the data for <code>v</code> is allocated on the stack and hence <code>new</code>/<code>delete</code> (<code>malloc</code>/<code>free</code>) overhead is avoided. However, for large vectors and matrices, this would be a Bad Thing since <code>Vector&lt;1000000&gt; v;</code> would result in an object of 8 megabytes being allocated on the stack and potentially overflowing it. TooN gets around that problem by having a cutoff at which statically sized vectors are allocated on the heap. This is completely transparent to the programmer, the objects' behaviour is unchanged and you still get the type safety offered by statically sized vectors and matrices. The cutoff size at which the library changes the representation is defined in <code><a class="el" href="TooN_8h_source.html">TooN.h</a></code> as the <code>const int TooN::Internal::max_bytes_on_stack=1000;</code>.</p>
<p>When you apply the subscript operator to a <code>Matrix&lt;3,3&gt;</code> and the function simply returns a vector which points to the the apropriate hunk of memory as a reference (i.e. it basically does no work apart from moving around a pointer). This avoids copying and also allows the resulting vector to be used as an l-value. Similarly the transpose operation applied to a matrix returns a matrix which referes to the same memory but with the opposite layout which also means the transpose can be used as an l-value so <code>M1 = M2.T();</code> and <code>M1.T() = M2;</code> do exactly the same thing.</p>
<p><b> Warning: This also means that <code>M = M.T();</code> does the wrong thing.</b> However, since .T() essentially costs nothing, it should be very rare that you need to do this.</p>
<h4><a class="anchor" id="ssDynamic"></a>
Dynamic sized vectors and matrices</h4>
<p>These are implemented in the obvious way using metadata with the rule that the object that allocated on the heap also deallocates. Other objects may reference the data (e.g. when you subscript a matrix and get a vector).</p>
<h3><a class="anchor" id="ssLazy"></a>
Return value optimisation vs Lazy evaluation</h3>
<p>When you write <code>v1 = M * v2;</code> a naive implementation will compute <code>M * v2</code> and store the result in a temporary object. It will then copy this temporary object into <code>v1</code>. A method often advanced to avoid this is to have <code>M * v2</code> simply return an special object <code>O</code> which contains references to <code>M</code> and <code>v2</code>. When the compiler then resolves <code>v1 = O</code>, the special object computes <code>M*v2</code> directly into <code>v1</code>. This approach is often called lazy evaluation and the special objects lazy vectors or lazy matrices. Stroustrup (The C++ programming language Chapter 22) refers to them as composition closure objects or compositors.</p>
<p>The killer is this: <b>What if v1 is just another name for v2?</b> i.e. you write something like <code>v = M * v;</code>. In this case the semantics have been broken because the values of <code>v</code> are being overwritten as the computation progresses and then the remainder of the computation is using the new values. In this library <code>v1</code> in the expression could equally well alias part of <code>M</code>, thus you can't even solve the problem by having a clever check for aliasing between <code>v1</code> and <code>v2</code>. This aliasing problem means that the only time the compiler can assume it's safe to omit the temporary is when <code>v1</code> is being constructed (and thus cannot alias anything else) i.e. <code>Vector&lt;3&gt; v1 = M * v2;</code>.</p>
<p>TooN provides this optimisation by providing the compiler with the opportunity to use a return value optimisation. It does this by making <code>M * v2</code> call a special constructor for <code>Vector&lt;3&gt;</code> with <code>M</code> and <code>v2</code> as arguments. Since nothing is happening between the construction of the temporary and the copy construction of <code>v1</code> from the temporary (which is then destroyed), the compiler is permitted to optimise the construction of the return value directly into <code>v1</code>.</p>
<p>Because a naive implemenation of this strategy would result in the vector and matrix classes having a very large number of constructors, these classes are provided with template constructors that take a standard form. The code that does this, declared in the header of class <code>Vector</code> is:</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Op&gt;
    <span class="keyword">inline</span> Vector(<span class="keyword">const</span> Operator&lt;Op&gt;&amp; op)
        : Base::template VLayout&lt;Size, Precision&gt; (op)
    {
        op.eval(*<span class="keyword">this</span>);
    }
</pre></div><h4><a class="anchor" id="ssHow"></a>
How it all really works</h4>
<p>This documentation is generated from a cleaned-up version of the interface, hiding the implementation that allows all of the magic to work. If you want to know more and can understand idioms like: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span>, <span class="keyword">typename</span>, <span class="keywordtype">int</span>, <span class="keyword">typename</span>&gt; <span class="keyword">struct </span>GenericVBase;
<span class="keyword">template</span>&lt;<span class="keywordtype">int</span>, <span class="keyword">typename</span>&gt; <span class="keyword">struct </span>VectorAlloc;

<span class="keyword">struct </span>VBase {
    <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Size, <span class="keyword">class</span> Precision&gt;
    <span class="keyword">struct </span>VLayout : <span class="keyword">public</span> GenericVBase&lt;Size, Precision, 1, VectorAlloc&lt;Size, Precision&gt; &gt; {
        ...
    };
};

<span class="keyword">template</span> &lt;<span class="keywordtype">int</span> Size, <span class="keyword">class</span> Precision, <span class="keyword">class</span> Base=VBase&gt;
<span class="keyword">class </span>Vector: <span class="keyword">public</span> Base::template VLayout&lt;Size, Precision&gt; {
   ...
};
</pre></div><p>then take a look at the source code ...</p>
<h2><a class="anchor" id="sManualConfiguration"></a>
Manual configuration</h2>
<p>Configuration is controlled by <code><a class="el" href="config_8hh_source.html">internal/config.hh</a></code>. If this file is empty then the default configuration will be used and <a class="el" href="namespaceTooN.html" title="Everything lives inside this namespace.">TooN</a> will work. There are several options.</p>
<h3><a class="anchor" id="stypeof"></a>
Typeof</h3>
<p><a class="el" href="namespaceTooN.html" title="Everything lives inside this namespace.">TooN</a> needs a mechanism to determine the type of the result of an expression. One of the following macros can be defined to control the behaviour:</p>
<ul>
<li><code>TOON_TYPEOF_DECLTYPE</code> <ul>
<li>Use the C++0x decltype operator.</li>
</ul>
</li>
<li><code>TOON_TYPEOF_TYPEOF</code> <ul>
<li>Use GCC's <code>typeof</code> extension. Only works with GCC and will fail with -pedantic</li>
</ul>
</li>
<li><code>TOON_TYPEOF___TYPEOF__</code> <ul>
<li>Use GCC's <code>__typeof__</code> extension. Only works with GCC and will work with -pedantic</li>
</ul>
</li>
<li><code>TOON_TYPEOF_BOOST</code> <ul>
<li>Use the <a class="el" href="">Boost.Typeof</a> system. This will work with Visual Studio if Boost is installed.</li>
</ul>
</li>
<li><code>TOON_TYPEOF_BUILTIN</code> <ul>
<li>The default option (does not need to be defined)</li>
<li>Only works for the standard builtin integral types and <code>std::complex&lt;float&gt;</code> and <code>std::complex&lt;double&gt;</code>.</li>
</ul>
</li>
</ul>
<p>Under Win32, the builtin typeof needs to be used. Comment out all the TOON_TYPEOF_ defines to use it.</p>
<h3><a class="anchor" id="sConfigLapack"></a>
Functions using LAPACK</h3>
<p>Some functions use internal implementations for small sizes and may switch over to LAPACK for larger sizes. In all cases, an equivalent method is used in terms of accuracy (eg Gaussian elimination versus LU decomposition). If the following macro is defined:</p>
<ul>
<li><code>TOON_USE_LAPACK</code> then LAPACK will be used for large systems, where optional. The individual functions are:</li>
<li><a class="el" href="group__gLinAlg.html#ga793d51b0c029eb6750d91a9afe4340ae" title="Compute the determinant of a matrix using an appropriate method.">TooN::determinant</a> is controlled by <code>TOON_DETERMINANT_LAPACK</code> <ul>
<li>If the macro is undefined as or defined as -1, then LAPACK will never be used. Otherwise it indicated which the size at which LAPACK should be used.</li>
</ul>
</li>
</ul>
<p>Note that these macros do not affect classes that are currently only wrappers around LAPACK. </p>
</div></div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Feb 8 2012 21:51:58 for TooN by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
