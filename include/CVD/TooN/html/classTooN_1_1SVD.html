<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TooN: SVD&lt; Rows, Cols, Precision &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TooN&#160;<span id="projectnumber">2.0.0-beta8</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceTooN.html">TooN</a>      </li>
      <li class="navelem"><a class="el" href="classTooN_1_1SVD.html">SVD</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">SVD&lt; Rows, Cols, Precision &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__gDecomps.html">Matrix decompositions</a></div></div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="TooN::SVD" -->
<p>Performs SVD and back substitute to solve equations.  
 <a href="classTooN_1_1SVD.html#details">More...</a></p>

<p><a href="classTooN_1_1SVD-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a170f13e2e213460b73343da5fce611b3"></a><!-- doxytag: member="TooN::SVD::SVD" ref="a170f13e2e213460b73343da5fce611b3" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTooN_1_1SVD.html#a170f13e2e213460b73343da5fce611b3">SVD</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac66300e7a5fd2bc44732f39caedf8236"></a><!-- doxytag: member="TooN::SVD::SVD" ref="ac66300e7a5fd2bc44732f39caedf8236" args="(int rows, int cols)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTooN_1_1SVD.html#ac66300e7a5fd2bc44732f39caedf8236">SVD</a> (int rows, int cols)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;int R2, int C2, typename P2 , typename B2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTooN_1_1SVD.html#a77414ed7abc2871264101e2649c7d7ca">SVD</a> (const <a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt; R2, C2, P2, B2 &gt; &amp;m)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ad2f4e563936eed1c5e9dff46222dc8c4"></a><!-- doxytag: member="TooN::SVD::compute" ref="ad2f4e563936eed1c5e9dff46222dc8c4" args="(const Matrix&lt; R2, C2, P2, B2 &gt; &amp;m)" -->
template&lt;int R2, int C2, typename P2 , typename B2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTooN_1_1SVD.html#ad2f4e563936eed1c5e9dff46222dc8c4">compute</a> (const <a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt; R2, C2, P2, B2 &gt; &amp;m)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;int Rows2, int Cols2, typename P2 , typename B2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt; Cols, Cols2, typename <br class="typebreak"/>
<a class="el" href="structTooN_1_1Internal_1_1MultiplyType.html">Internal::MultiplyType</a><br class="typebreak"/>
&lt; Precision, P2 &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTooN_1_1SVD.html#adfe6e7de53ac6f321c74d7add8fd37cc">backsub</a> (const <a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt; Rows2, Cols2, P2, B2 &gt; &amp;rhs, const Precision condition=condition_no)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;int Size, typename P2 , typename B2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTooN_1_1Vector.html">Vector</a>&lt; Cols, typename <br class="typebreak"/>
<a class="el" href="structTooN_1_1Internal_1_1MultiplyType.html">Internal::MultiplyType</a><br class="typebreak"/>
&lt; Precision, P2 &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTooN_1_1SVD.html#a6a0b26da34e4394372efe1bb36dc6f70">backsub</a> (const <a class="el" href="structTooN_1_1Vector.html">Vector</a>&lt; Size, P2, B2 &gt; &amp;rhs, const Precision condition=condition_no)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt; Cols, Rows &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTooN_1_1SVD.html#ae5b8bb25f63c9c791de3bf0881d64af2">get_pinv</a> (const Precision condition=condition_no)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48a020ba81023b416d257c116edb3d93"></a><!-- doxytag: member="TooN::SVD::determinant" ref="a48a020ba81023b416d257c116edb3d93" args="()" -->
Precision&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTooN_1_1SVD.html#a48a020ba81023b416d257c116edb3d93">determinant</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTooN_1_1SVD.html#a4f34f94db493642e5875ce17337a0f25">rank</a> (const Precision condition=condition_no)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59d0c00dd267b098402b3e68b3106ac1"></a><!-- doxytag: member="TooN::SVD::get_U" ref="a59d0c00dd267b098402b3e68b3106ac1" args="()" -->
<a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt; Rows, Min_Dim, <br class="typebreak"/>
Precision, <a class="el" href="structTooN_1_1Reference_1_1RowMajor.html">Reference::RowMajor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTooN_1_1SVD.html#a59d0c00dd267b098402b3e68b3106ac1">get_U</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b4de40a18d7c29937c4b35bd98adbce"></a><!-- doxytag: member="TooN::SVD::get_diagonal" ref="a8b4de40a18d7c29937c4b35bd98adbce" args="()" -->
<a class="el" href="structTooN_1_1Vector.html">Vector</a>&lt; Min_Dim, Precision &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTooN_1_1SVD.html#a8b4de40a18d7c29937c4b35bd98adbce">get_diagonal</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1cd9b5bc1563601cf30da46b896b6f7"></a><!-- doxytag: member="TooN::SVD::get_VT" ref="ad1cd9b5bc1563601cf30da46b896b6f7" args="()" -->
<a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt; Min_Dim, Cols, <br class="typebreak"/>
Precision, <a class="el" href="structTooN_1_1Reference_1_1RowMajor.html">Reference::RowMajor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTooN_1_1SVD.html#ad1cd9b5bc1563601cf30da46b896b6f7">get_VT</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTooN_1_1SVD.html#a0ad8bb813e667091df5be2455b114ee0">get_inv_diag</a> (<a class="el" href="structTooN_1_1Vector.html">Vector</a>&lt; Min_Dim &gt; &amp;inv_diag, const Precision condition)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;int Rows = Dynamic, int Cols = Rows, typename Precision = DefaultPrecision&gt;<br/>
class TooN::SVD&lt; Rows, Cols, Precision &gt;</h3>

<p>Performs SVD and back substitute to solve equations. </p>
<p>Singular value decompositions are more robust than <a class="el" href="classTooN_1_1LU.html" title="Performs LU decomposition and back substitutes to solve equations.">LU</a> decompositions in the face of singular or nearly singular matrices. They decompose a matrix (of any shape) <img class="formulaInl" alt="$M$" src="form_24.png"/> into: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[M = U \times D \times V^T\]" src="form_54.png"/>
</p>
<p> where <img class="formulaInl" alt="$D$" src="form_55.png"/> is a diagonal matrix of positive numbers whose dimension is the minimum of the dimensions of <img class="formulaInl" alt="$M$" src="form_24.png"/>. If <img class="formulaInl" alt="$M$" src="form_24.png"/> is tall and thin (more rows than columns) then <img class="formulaInl" alt="$U$" src="form_27.png"/> has the same shape as <img class="formulaInl" alt="$M$" src="form_24.png"/> and <img class="formulaInl" alt="$V$" src="form_56.png"/> is square (vice-versa if <img class="formulaInl" alt="$M$" src="form_24.png"/> is short and fat). The columns of <img class="formulaInl" alt="$U$" src="form_27.png"/> and the rows of <img class="formulaInl" alt="$V$" src="form_56.png"/> are orthogonal and of unit norm (so one of them lies in SO(N)). The inverse of <img class="formulaInl" alt="$M$" src="form_24.png"/> (or pseudo-inverse if <img class="formulaInl" alt="$M$" src="form_24.png"/> is not square) is then given by </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[M^{\dagger} = V \times D^{-1} \times U^T\]" src="form_57.png"/>
</p>
<p>If <img class="formulaInl" alt="$M$" src="form_24.png"/> is nearly singular then the diagonal matrix <img class="formulaInl" alt="$D$" src="form_55.png"/> has some small values (relative to its largest value) and these terms dominate <img class="formulaInl" alt="$D^{-1}$" src="form_58.png"/>. To deal with this problem, the inverse is conditioned by setting a maximum ratio between the largest and smallest values in <img class="formulaInl" alt="$D$" src="form_55.png"/> (passed as the <code>condition</code> parameter to the various functions). Any values which are too small are set to zero in the inverse (rather than a large number)</p>
<p>It can be used as follows to solve the <img class="formulaInl" alt="$M\underline{x} = \underline{c}$" src="form_23.png"/> problem as follows: </p>
<div class="fragment"><pre class="fragment"><span class="comment">// construct M</span>
Matrix&lt;3&gt; M;
M[0] = makeVector(1,2,3);
M[1] = makeVector(4,5,6);
M[2] = makeVector(7,8.10);
<span class="comment">// construct c</span>
 Vector&lt;3&gt; c;
c = 2,3,4;
<span class="comment">// create the SVD decomposition of M</span>
SVD&lt;3&gt; svdM(M);
<span class="comment">// compute x = M^-1 * c</span>
Vector&lt;3&gt; x = svdM.backsub(c);
</pre></div><p>SVD&lt;&gt; (= <a class="el" href="classTooN_1_1SVD.html" title="Performs SVD and back substitute to solve equations.">SVD</a>&lt;-1&gt;) can be used to create an <a class="el" href="classTooN_1_1SVD.html" title="Performs SVD and back substitute to solve equations.">SVD</a> whose size is determined at run-time. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a77414ed7abc2871264101e2649c7d7ca"></a><!-- doxytag: member="TooN::SVD::SVD" ref="a77414ed7abc2871264101e2649c7d7ca" args="(const Matrix&lt; R2, C2, P2, B2 &gt; &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTooN_1_1SVD.html">SVD</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt; R2, C2, P2, B2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct the SVD decomposition of a matrix. </p>
<p>This initialises the class, and performs the decomposition immediately. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="adfe6e7de53ac6f321c74d7add8fd37cc"></a><!-- doxytag: member="TooN::SVD::backsub" ref="adfe6e7de53ac6f321c74d7add8fd37cc" args="(const Matrix&lt; Rows2, Cols2, P2, B2 &gt; &amp;rhs, const Precision condition=condition_no)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt;Cols,Cols2, typename <a class="el" href="structTooN_1_1Internal_1_1MultiplyType.html">Internal::MultiplyType</a>&lt;Precision,P2&gt;::type &gt; backsub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt; Rows2, Cols2, P2, B2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Precision&#160;</td>
          <td class="paramname"><em>condition</em> = <code>condition_no</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate result of multiplying the (pseudo-)inverse of M by another matrix. </p>
<p>For a matrix <img class="formulaInl" alt="$A$" src="form_3.png"/>, this calculates <img class="formulaInl" alt="$M^{\dagger}A$" src="form_5.png"/> by back substitution (i.e. without explictly calculating the (pseudo-)inverse). See the detailed description for a description of condition variables. </p>

</div>
</div>
<a class="anchor" id="a6a0b26da34e4394372efe1bb36dc6f70"></a><!-- doxytag: member="TooN::SVD::backsub" ref="a6a0b26da34e4394372efe1bb36dc6f70" args="(const Vector&lt; Size, P2, B2 &gt; &amp;rhs, const Precision condition=condition_no)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTooN_1_1Vector.html">Vector</a>&lt;Cols, typename <a class="el" href="structTooN_1_1Internal_1_1MultiplyType.html">Internal::MultiplyType</a>&lt;Precision,P2&gt;::type &gt; backsub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTooN_1_1Vector.html">Vector</a>&lt; Size, P2, B2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Precision&#160;</td>
          <td class="paramname"><em>condition</em> = <code>condition_no</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate result of multiplying the (pseudo-)inverse of M by a vector. </p>
<p>For a vector <img class="formulaInl" alt="$b$" src="form_4.png"/>, this calculates <img class="formulaInl" alt="$M^{\dagger}b$" src="form_6.png"/> by back substitution (i.e. without explictly calculating the (pseudo-)inverse). See the detailed description for a description of condition variables. </p>

</div>
</div>
<a class="anchor" id="ae5b8bb25f63c9c791de3bf0881d64af2"></a><!-- doxytag: member="TooN::SVD::get_pinv" ref="ae5b8bb25f63c9c791de3bf0881d64af2" args="(const Precision condition=condition_no)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt;Cols,Rows&gt; get_pinv </td>
          <td>(</td>
          <td class="paramtype">const Precision&#160;</td>
          <td class="paramname"><em>condition</em> = <code>condition_no</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate (pseudo-)inverse of the matrix. </p>
<p>This is not usually needed: if you need the inverse just to multiply it by a matrix or a vector, use one of the <a class="el" href="classTooN_1_1SVD.html#adfe6e7de53ac6f321c74d7add8fd37cc" title="Calculate result of multiplying the (pseudo-)inverse of M by another matrix.">backsub()</a> functions, which will be faster. See the detailed description of the pseudo-inverse and condition variables. </p>

</div>
</div>
<a class="anchor" id="a4f34f94db493642e5875ce17337a0f25"></a><!-- doxytag: member="TooN::SVD::rank" ref="a4f34f94db493642e5875ce17337a0f25" args="(const Precision condition=condition_no)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rank </td>
          <td>(</td>
          <td class="paramtype">const Precision&#160;</td>
          <td class="paramname"><em>condition</em> = <code>condition_no</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the rank of the matrix. </p>
<p>See the detailed description of the pseudo-inverse and condition variables. </p>

</div>
</div>
<a class="anchor" id="a0ad8bb813e667091df5be2455b114ee0"></a><!-- doxytag: member="TooN::SVD::get_inv_diag" ref="a0ad8bb813e667091df5be2455b114ee0" args="(Vector&lt; Min_Dim &gt; &amp;inv_diag, const Precision condition)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void get_inv_diag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTooN_1_1Vector.html">Vector</a>&lt; Min_Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>inv_diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Precision&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the pesudo-inverse diagonal. </p>
<p>The reciprocal of the diagonal elements is returned if the elements are well scaled with respect to the largest element, otherwise 0 is returned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inv_diag</td><td><a class="el" href="structTooN_1_1Vector.html" title="A vector.">Vector</a> in which to return the inverse diagonal. </td></tr>
    <tr><td class="paramname">condition</td><td>Elements must be larger than this factor times the largest diagonal element to be considered well scaled. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classTooN_1_1SVD.html#adfe6e7de53ac6f321c74d7add8fd37cc">SVD&lt; Size, Size, Precision &gt;::backsub()</a>, and <a class="el" href="classTooN_1_1SVD.html#ae5b8bb25f63c9c791de3bf0881d64af2">SVD&lt; Size, Size, Precision &gt;::get_pinv()</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Feb 8 2012 21:52:00 for TooN by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
