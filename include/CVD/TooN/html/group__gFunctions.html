<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TooN: Evaluation of functions.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TooN&#160;<span id="projectnumber">2.0.0-beta8</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Evaluation of functions.</div>  </div>
</div>
<div class="contents">

<p>Evaluation of useful functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class F , int S, class P , class B &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTooN_1_1Vector.html">Vector</a>&lt; S, P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gFunctions.html#gaadcd6e789c3e02985fb92f12d76336c8">numerical_gradient</a> (const F &amp;f, const <a class="el" href="structTooN_1_1Vector.html">Vector</a>&lt; S, P, B &gt; &amp;x)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class F , int S, class P , class B &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt; S, 2, P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gFunctions.html#gae00502cab5e9fecc222b40acd502a669">numerical_gradient_with_errors</a> (const F &amp;f, const <a class="el" href="structTooN_1_1Vector.html">Vector</a>&lt; S, P, B &gt; &amp;x)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class F , int S, class P , class B &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">pair&lt; <a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt; S, S, P &gt;<br class="typebreak"/>
, <a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt; S, S, P &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gFunctions.html#gae25d3990c23c57b7b820b8489f7c2690">numerical_hessian_with_errors</a> (const F &amp;f, const <a class="el" href="structTooN_1_1Vector.html">Vector</a>&lt; S, P, B &gt; &amp;x)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class F , int S, class P , class B &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt; S, S, P &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gFunctions.html#gaa959044c09941adbb35ba9cade9a9aaf">numerical_hessian</a> (const F &amp;f, const <a class="el" href="structTooN_1_1Vector.html">Vector</a>&lt; S, P, B &gt; &amp;x)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>Evaluation of useful functions. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaadcd6e789c3e02985fb92f12d76336c8"></a><!-- doxytag: member="TooN::numerical_gradient" ref="gaadcd6e789c3e02985fb92f12d76336c8" args="(const F &amp;f, const Vector&lt; S, P, B &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTooN_1_1Vector.html">Vector</a>&lt;S, P&gt; TooN::numerical_gradient </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTooN_1_1Vector.html">Vector</a>&lt; S, P, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extrapolate a derivative to zero using Ridder's Algorithm. </p>
<p>Ridder's algorithm works by evaluating derivatives with smaller and smaller step sizes, fitting a polynomial and extrapolating its value to zero.</p>
<p>This algorithm is generally more accurate and much more reliable, but much slower than using simple finite differences. It is robust to awkward functions and does not require careful tuning of the step size, furthermore it provides an estimate of the errors. This implementation has been tuned for accuracy instead of speed. For an estimate of the errors, see also <a class="el" href="group__gFunctions.html#gae00502cab5e9fecc222b40acd502a669" title="Compute numerical gradients with errors.">numerical_gradient_with_errors()</a>. In general it is useful to know the errors since some functions are remarkably hard to differentiate numerically.</p>
<p>Neville's Algorithm can be used to find a point on a fitted polynomial at <img class="formulaInl" alt="$h$" src="form_106.png"/>. Taking some points <img class="formulaInl" alt="$h_i$" src="form_107.png"/> and <img class="formulaInl" alt="$ y_i = f(h_i)$" src="form_108.png"/>, one can define a table of points on various polyomials: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \begin{array}{ccccccc} h_0 &amp; y_0 &amp; P_0 &amp; &amp; &amp; \\ &amp; &amp; &amp; P_{01} &amp; &amp; \\ h_1 &amp; y_1 &amp; P_1 &amp; &amp; P_{012} &amp; \\ &amp; &amp; &amp; P_{12} &amp; &amp; P_{0123} \\ h_2 &amp; y_2 &amp; P_2 &amp; &amp; P_{123} &amp; \\ &amp; &amp; &amp; P_{23} &amp; &amp; \\ h_3 &amp; y_3 &amp; P_3 &amp; &amp; &amp; \\ \end{array} \]" src="form_109.png"/>
</p>
<p> where <img class="formulaInl" alt="$P_{123}$" src="form_110.png"/> is the value of a polynomial fitted to datapoints 1, 2 and 3 evaluated at <img class="formulaInl" alt="$ h$" src="form_111.png"/>. The initial values are simple to evaluate: <img class="formulaInl" alt="$P_i = y_i = f(h_i)$" src="form_112.png"/>. The remaining values are determined by the recurrance: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} P_{k\cdots n} = \frac{(h - h_n)P_{k \cdots n-1} + (h_k - h)P_{k+1 \cdots n}}{h_k - h_n} \end{equation}" src="form_113.png"/>
</p>
<p>For Ridder's algorithm, we define the extrapolation point <img class="formulaInl" alt="$ h=0 $" src="form_114.png"/> and the sequence of points to evaluate as <img class="formulaInl" alt="$ h_i = c^{-i} $" src="form_115.png"/> where <img class="formulaInl" alt="$ c $" src="form_116.png"/> is some constant a little greater than 1. Substituting in to the above equation gives: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ P_{k \cdots n} = \frac{c^{-k} P_{k+1 \cdots n} - P_{k \cdots n-1}}{c^{n - k} - 1} \]" src="form_117.png"/>
</p>
<p>To measure errors, when computing (for example) <img class="formulaInl" alt="$P_{234}$" src="form_118.png"/>, we compare the value to the lower order with the same step size <img class="formulaInl" alt="$P_{34}$" src="form_119.png"/>, and the lower order with a larger step size <img class="formulaInl" alt="$P_{23}$" src="form_120.png"/>. The error estimate is the largest of these. The extrapolation with the smallest error is retained.</p>
<p>Not only that, but since every value of P is used, every single subset of points is used for polynomial fitting. So, bad points for large and small <img class="formulaInl" alt="$h$" src="form_106.png"/> do not spoil the answer.</p>
<p>It is generally assumed that as <img class="formulaInl" alt="$h$" src="form_106.png"/> decreases, the errors decrease, then increase again. Therefore, if the current step size did not yield any improvements on the best point so far, then we terminate when the highest order point is <img class="formulaInl" alt="$ t $" src="form_121.png"/> times worse then the previous order point.</p>
<p>The parameters are:</p>
<ul>
<li><img class="formulaInl" alt="$ c = 1.1 $" src="form_122.png"/></li>
<li><img class="formulaInl" alt="$ t = 2 $" src="form_123.png"/></li>
<li>Max iterations = 400</li>
</ul>
<h2><a class="anchor" id="rRef"></a>
References</h2>
<ul>
<li>Ridders, C. J. F, 1982, Advances in Engineering Software, 4(2) 75--76</li>
<li>Press, Vetterling, Teukolsky, Flannery, Numerical, 1997, Numerical Recipies in C (2nd ed.), Chapter 5.7</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Functor to differentiate </td></tr>
    <tr><td class="paramname">x</td><td>Point about which to differentiate. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structTooN_1_1Vector.html#ab8e4e3e2a7bf18888b71bdf9dda0770b">Vector&lt; Size, Precision, Base &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="gae00502cab5e9fecc222b40acd502a669"></a><!-- doxytag: member="TooN::numerical_gradient_with_errors" ref="gae00502cab5e9fecc222b40acd502a669" args="(const F &amp;f, const Vector&lt; S, P, B &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt;S,2,P&gt; TooN::numerical_gradient_with_errors </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTooN_1_1Vector.html">Vector</a>&lt; S, P, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute numerical gradients with errors. </p>
<p>See <a class="el" href="group__gFunctions.html#gaadcd6e789c3e02985fb92f12d76336c8" title="Extrapolate a derivative to zero using Ridder&#39;s Algorithm.">numerical_gradient()</a>. Gradients are returned in the first row of the returned matrix. Errors are returned in the second row. The errors have not been scaled, so they are in the same range as the gradients. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Functor to differentiate </td></tr>
    <tr><td class="paramname">x</td><td>Point about which to differentiate. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structTooN_1_1Vector.html#ab8e4e3e2a7bf18888b71bdf9dda0770b">Vector&lt; Size, Precision, Base &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="gae25d3990c23c57b7b820b8489f7c2690"></a><!-- doxytag: member="TooN::numerical_hessian_with_errors" ref="gae25d3990c23c57b7b820b8489f7c2690" args="(const F &amp;f, const Vector&lt; S, P, B &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;<a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt;S, S, P&gt;, <a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt;S, S, P&gt; &gt; TooN::numerical_hessian_with_errors </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTooN_1_1Vector.html">Vector</a>&lt; S, P, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the numerical Hessian using central differences and Ridder's method: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial^2 f}{\partial x^2} \approx \frac{f(x-h) - 2f(x) + f(x+h)}{h^2} \]" src="form_124.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \frac{\partial^2 f}{\partial x\partial y} \approx \frac{f(x+h, y+h) - f(x-h,y+h) - f(x+h, y-h) + f(x-h, y-h)}{4h^2} \]" src="form_125.png"/>
</p>
<p> See <a class="el" href="group__gFunctions.html#gaadcd6e789c3e02985fb92f12d76336c8" title="Extrapolate a derivative to zero using Ridder&#39;s Algorithm.">numerical_gradient()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Functor to double-differentiate </td></tr>
    <tr><td class="paramname">x</td><td>Point about which to double-differentiate. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structTooN_1_1Vector.html#ab8e4e3e2a7bf18888b71bdf9dda0770b">Vector&lt; Size, Precision, Base &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa959044c09941adbb35ba9cade9a9aaf"></a><!-- doxytag: member="TooN::numerical_hessian" ref="gaa959044c09941adbb35ba9cade9a9aaf" args="(const F &amp;f, const Vector&lt; S, P, B &gt; &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt;S, S, P&gt; TooN::numerical_hessian </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTooN_1_1Vector.html">Vector</a>&lt; S, P, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the numerical Hessian and errors. </p>
<p>The Hessian is returned as the first element, and the errors as the second. See <a class="el" href="group__gFunctions.html#gaa959044c09941adbb35ba9cade9a9aaf" title="Compute the numerical Hessian and errors.">numerical_hessian()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Functor to double-differentiate </td></tr>
    <tr><td class="paramname">x</td><td>Point about which to double-differentiate. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structTooN_1_1Vector.html#ab8e4e3e2a7bf18888b71bdf9dda0770b">Vector&lt; Size, Precision, Base &gt;::size()</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Feb 8 2012 21:51:59 for TooN by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
