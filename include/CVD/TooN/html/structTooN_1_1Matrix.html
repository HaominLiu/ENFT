<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TooN: Matrix&lt; Rows, Cols, Precision, Layout &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TooN&#160;<span id="projectnumber">2.0.0-beta8</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceTooN.html">TooN</a>      </li>
      <li class="navelem"><a class="el" href="structTooN_1_1Matrix.html">Matrix</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Matrix&lt; Rows, Cols, Precision, Layout &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__gLinAlg.html">Linear Algebra</a></div></div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="TooN::Matrix" -->
<p>A matrix.  
 <a href="structTooN_1_1Matrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="matrix_8hh_source.html">matrix.hh</a>&gt;</code></p>

<p><a href="structTooN_1_1Matrix-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTooN_1_1Matrix.html#ad9e754c85d19943cf4c206139972f0fc">operator()</a> (int r, int c) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTooN_1_1Matrix.html#a1fd155aa666835b5c154e3a9add6b1eb">operator[]</a> (const std::pair&lt; int, int &gt; &amp;row_col) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac50b6039938302b2c309523eb82e587c"></a><!-- doxytag: member="TooN::Matrix::operator[]" ref="ac50b6039938302b2c309523eb82e587c" args="(const std::pair&lt; int, int &gt; &amp;row_col)" -->
double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTooN_1_1Matrix.html#ac50b6039938302b2c309523eb82e587c">operator[]</a> (const std::pair&lt; int, int &gt; &amp;row_col)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTooN_1_1Matrix.html#a99e08a9711750afc9fd6811c75e44d62">operator()</a> (int r, int c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structTooN_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTooN_1_1Matrix.html#a3ac48ce8528ce00c55fe678ce40216e9">operator[]</a> (int r) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTooN_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTooN_1_1Matrix.html#a80b44795c876c2392f48496486fd1a4b">operator[]</a> (int r)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a488f4c0ba4770627726afa820ccc20ea"></a><!-- doxytag: member="TooN::Matrix::num_rows" ref="a488f4c0ba4770627726afa820ccc20ea" args="() const " -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTooN_1_1Matrix.html#a488f4c0ba4770627726afa820ccc20ea">num_rows</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add73bcc1d947cc0cded736aa16f36f58"></a><!-- doxytag: member="TooN::Matrix::num_cols" ref="add73bcc1d947cc0cded736aa16f36f58" args="() const " -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTooN_1_1Matrix.html#add73bcc1d947cc0cded736aa16f36f58">num_cols</a> () const </td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction and destruction</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3aede62f513da27e6f61ae7a972b4f96"></a><!-- doxytag: member="TooN::Matrix::Matrix" ref="a3aede62f513da27e6f61ae7a972b4f96" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTooN_1_1Matrix.html#a3aede62f513da27e6f61ae7a972b4f96">Matrix</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab88e590a4c2f2b5d0385519fa9c708af"></a><!-- doxytag: member="TooN::Matrix::Matrix" ref="ab88e590a4c2f2b5d0385519fa9c708af" args="(int rows, int cols)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTooN_1_1Matrix.html#ab88e590a4c2f2b5d0385519fa9c708af">Matrix</a> (int rows, int cols)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2723cf0151f7634ac5b209815a6ec5c4"></a><!-- doxytag: member="TooN::Matrix::Matrix" ref="a2723cf0151f7634ac5b209815a6ec5c4" args="(Precision *p)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTooN_1_1Matrix.html#a2723cf0151f7634ac5b209815a6ec5c4">Matrix</a> (Precision *p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80f4e1b3503b168a0e0a81613532fa1b"></a><!-- doxytag: member="TooN::Matrix::Matrix" ref="a80f4e1b3503b168a0e0a81613532fa1b" args="(Precision *p, int r, int c)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTooN_1_1Matrix.html#a80f4e1b3503b168a0e0a81613532fa1b">Matrix</a> (Precision *p, int r, int c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTooN_1_1Matrix.html#a722c9c93c228a800dd52d6faa7c9e52e">Matrix</a> (Precision *data, int rows, int cols, int rowstride, int colstride, <a class="el" href="structTooN_1_1Internal_1_1Slicing.html">Internal::Slicing</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ad793ea42a890a35cdb7beac98166df02"></a><!-- doxytag: member="TooN::Matrix::Matrix" ref="ad793ea42a890a35cdb7beac98166df02" args="(const Operator&lt; Op &gt; &amp;op)" -->
template&lt;class Op &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structTooN_1_1Matrix.html#ad793ea42a890a35cdb7beac98166df02">Matrix</a> (const <a class="el" href="structTooN_1_1Operator.html">Operator</a>&lt; Op &gt; &amp;op)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a1d6d55943441ccc7e958ea7ad02340ab"></a><!-- doxytag: member="TooN::Matrix::Matrix" ref="a1d6d55943441ccc7e958ea7ad02340ab" args="(const Matrix&lt; Rows2, Cols2, Precision2, Base2 &gt; &amp;from)" -->
template&lt;int Rows2, int Cols2, typename Precision2 , typename Base2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structTooN_1_1Matrix.html#a1d6d55943441ccc7e958ea7ad02340ab">Matrix</a> (const <a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt; Rows2, Cols2, Precision2, Base2 &gt; &amp;from)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assignment</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>operator = from copy </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a036524e544942d3f2f106b9dc0365867"></a><!-- doxytag: member="TooN::Matrix::operator=" ref="a036524e544942d3f2f106b9dc0365867" args="(const Matrix &amp;from)" -->
<a class="el" href="structTooN_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="structTooN_1_1Matrix.html">Matrix</a> &amp;from)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ae91c545a33c3310808aaaccdb34ecdd4"></a><!-- doxytag: member="TooN::Matrix::operator=" ref="ae91c545a33c3310808aaaccdb34ecdd4" args="(const Operator&lt; Op &gt; &amp;op)" -->
template&lt;class Op &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTooN_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="structTooN_1_1Operator.html">Operator</a>&lt; Op &gt; &amp;op)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ab7ad431eb886da2e0b8647af74f71a78"></a><!-- doxytag: member="TooN::Matrix::operator=" ref="ab7ad431eb886da2e0b8647af74f71a78" args="(const Matrix&lt; Rows2, Cols2, Precision2, Base2 &gt; &amp;from)" -->
template&lt;int Rows2, int Cols2, typename Precision2 , typename Base2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTooN_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt; Rows2, Cols2, Precision2, Base2 &gt; &amp;from)</td></tr>
<tr><td colspan="2"><div class="groupHeader">operations on the matrix</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a785d7aa6eba15d8836a5e1c377804149"></a><!-- doxytag: member="TooN::Matrix::operator*=" ref="a785d7aa6eba15d8836a5e1c377804149" args="(const Precision &amp;rhs)" -->
<a class="el" href="structTooN_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (const Precision &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9ffc4218c543db9d7f814c3b2d28a64"></a><!-- doxytag: member="TooN::Matrix::operator/=" ref="ad9ffc4218c543db9d7f814c3b2d28a64" args="(const Precision &amp;rhs)" -->
<a class="el" href="structTooN_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator/=</b> (const Precision &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a31889e47c70715f912df12a38f361ca0"></a><!-- doxytag: member="TooN::Matrix::operator+=" ref="a31889e47c70715f912df12a38f361ca0" args="(const Matrix&lt; Rows2, Cols2, Precision2, Base2 &gt; &amp;from)" -->
template&lt;int Rows2, int Cols2, typename Precision2 , typename Base2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTooN_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt; Rows2, Cols2, Precision2, Base2 &gt; &amp;from)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ad02722d57368bfbd469f568fb480bd3b"></a><!-- doxytag: member="TooN::Matrix::operator+=" ref="ad02722d57368bfbd469f568fb480bd3b" args="(const Operator&lt; Op &gt; &amp;op)" -->
template&lt;class Op &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTooN_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="structTooN_1_1Operator.html">Operator</a>&lt; Op &gt; &amp;op)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a47b613fef2d48b3ff7ad498bb5862df0"></a><!-- doxytag: member="TooN::Matrix::operator&#45;=" ref="a47b613fef2d48b3ff7ad498bb5862df0" args="(const Operator&lt; Op &gt; &amp;op)" -->
template&lt;class Op &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTooN_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="structTooN_1_1Operator.html">Operator</a>&lt; Op &gt; &amp;op)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a4cbfbefe74122d18232747c4cc5807a6"></a><!-- doxytag: member="TooN::Matrix::operator&#45;=" ref="a4cbfbefe74122d18232747c4cc5807a6" args="(const Matrix&lt; Rows2, Cols2, Precision2, Base2 &gt; &amp;from)" -->
template&lt;int Rows2, int Cols2, typename Precision2 , typename Base2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTooN_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-=</b> (const <a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt; Rows2, Cols2, Precision2, Base2 &gt; &amp;from)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a41567415e34a40737737e5c7d800d64d"></a><!-- doxytag: member="TooN::Matrix::operator==" ref="a41567415e34a40737737e5c7d800d64d" args="(const Matrix&lt; Rows2, Cols2, Precision2, Base2 &gt; &amp;rhs) const " -->
template&lt;int Rows2, int Cols2, typename Precision2 , typename Base2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt; Rows2, Cols2, Precision2, Base2 &gt; &amp;rhs) const </td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a62a1acaed5a43629a66cf382d93d4232"></a><!-- doxytag: member="TooN::Matrix::operator!=" ref="a62a1acaed5a43629a66cf382d93d4232" args="(const Matrix&lt; Rows2, Cols2, Precision2, Base2 &gt; &amp;rhs) const " -->
template&lt;int Rows2, int Cols2, typename Precision2 , typename Base2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt; Rows2, Cols2, Precision2, Base2 &gt; &amp;rhs) const </td></tr>
<tr><td colspan="2"><div class="groupHeader">Misc</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93e810460acfeb7d6ea247e35bf05f18"></a><!-- doxytag: member="TooN::Matrix::ref" ref="a93e810460acfeb7d6ea247e35bf05f18" args="()" -->
<a class="el" href="structTooN_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTooN_1_1Matrix.html#a93e810460acfeb7d6ea247e35bf05f18">ref</a> ()</td></tr>
<tr><td colspan="2"><div class="groupHeader">Transpose and sub-matrices</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt; Cols, Rows &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTooN_1_1Matrix.html#a5de36a6a2dd9d3b3c88cf04337e0dcf0">T</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt; Cols, Rows &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTooN_1_1Matrix.html#a103cfb9adb98ba245872bd6f98b1c211">T</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;Rstart , Cstart , Rsize , Csize &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt; Rsize, Csize &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structTooN_1_1Matrix.html#a53b254fb71baceda82834745cef2c60b">slice</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;Rstart , Cstart , Rsize , Csize &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt; Rsize, Csize &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structTooN_1_1Matrix.html#af7b485aa536050f3d50d846c15543b03">slice</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structTooN_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTooN_1_1Matrix.html#a8e6dd43172fbe373c0e1bd184411a382">slice</a> (int rstart, int cstart, int rsize, int csize) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTooN_1_1Matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTooN_1_1Matrix.html#a6e17789077ce550be82c9c073260f2b8">slice</a> (int rstart, int cstart, int rsize, int csize)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;int Rows = -1, int Cols = Rows, class Precision = DefaultPrecision, class Layout = RowMajor&gt;<br/>
struct TooN::Matrix&lt; Rows, Cols, Precision, Layout &gt;</h3>

<p>A matrix. </p>
<p>Support is provided for all the usual matrix operations:</p>
<ul>
<li>the (a,b) notation can be used to access an element directly</li>
<li>the [] operator can be used to yield a vector from a matrix (which can be used as an l-value)</li>
<li>they can be added and subtracted</li>
<li>they can be multiplied (on either side) or divided by a scalar on the right:</li>
<li>they can be multiplied by matrices or vectors</li>
<li>submatrices can be extracted using the templated <a class="el" href="structTooN_1_1Matrix.html#af7b485aa536050f3d50d846c15543b03" title="Extract a sub-matrix.">slice()</a> member function</li>
<li>they can be transposed (and the transpose used as an l-value)</li>
<li>inverse is <em>not</em> supported. Use one of the <a class="el" href="group__gDecomps.html">matrix decompositions </a> instead</li>
</ul>
<p>See individual member function documentation for examples of usage.</p>
<dl class="user"><dt><b>Statically-sized matrices</b></dt><dd></dd></dl>
<p>The library provides classes for statically and dynamically sized matrices. As with <a class="el" href="structTooN_1_1Vector.html">Vectors</a>, statically sized matrices are more efficient, since their size is determined at compile-time, not run-time. To create a <img class="formulaInl" alt="$3\times4$" src="form_104.png"/> matrix, use: </p>
<div class="fragment"><pre class="fragment">Matrix&lt;3,4&gt; M;
</pre></div><p> or replace 3 and 4 with the dimensions of your choice. If the matrix is square, it can be declared as: </p>
<div class="fragment"><pre class="fragment">Matrix&lt;3&gt; M;
</pre></div><p> which just is a synonym for <code>Matrix&lt;3,3&gt;</code>. Matrices can also be constructed from pointers or static 1D or 2D arrays of doubles: </p>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">double</span> dvals1[9]={1,2,3,4,5,6};
  Matrix&lt;2,3, Reference::RowMajor&gt; M2 (dvals1);
</pre></div><dl class="user"><dt><b>Dynamically-sized matrices</b></dt><dd></dd></dl>
<p>To create a dynamically sized matrix, use: </p>
<div class="fragment"><pre class="fragment">Matrix&lt;&gt; M(<a class="code" href="structTooN_1_1Matrix.html#a488f4c0ba4770627726afa820ccc20ea" title="How many rows does this matrix have?">num_rows</a>, <a class="code" href="structTooN_1_1Matrix.html#add73bcc1d947cc0cded736aa16f36f58" title="How many columns does this matrix have?">num_cols</a>);
</pre></div><p> where <em>num_rows</em> and <em>num_cols</em> are integers which will be evaluated at run time.</p>
<p>Half-dynamic matriced can be constructed in either dimension: </p>
<div class="fragment"><pre class="fragment">    Matrix&lt;Dynamic, 2&gt; M(<a class="code" href="structTooN_1_1Matrix.html#a488f4c0ba4770627726afa820ccc20ea" title="How many rows does this matrix have?">num_rows</a>, 2);
</pre></div><p> note that the static dimension must be provided, but it is ignored.</p>
<p><code>Matrix&lt;&gt;</code> is a synonym for <code> Matrix&lt;Dynamic, Dynamic&gt; </code> which is <code>Matrix&lt;-1,-1&gt;</code></p>
<dl class="user"><dt><b>Row-major and column-major</b></dt><dd></dd></dl>
<p>The library supports both row major (the default - but you can change this if you prefer) and column major layout ordering. Row major implies that the matrix is laid out in memory in raster scan order: </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[\begin{matrix}\text{Row major} &amp; \text {Column major}\\ \begin{bmatrix}1&amp;2&amp;3\\4&amp;5&amp;6\\7&amp;8&amp;9\end{bmatrix} &amp; \begin{bmatrix}1&amp;4&amp;7\\2&amp;5&amp;8\\3&amp;6&amp;9\end{bmatrix} \end{matrix}\]" src="form_105.png"/>
</p>
<p> You can override the default for a specific matrix by specifying the layout when you construct it: </p>
<div class="fragment"><pre class="fragment">Matrix&lt;3,3,double,ColMajor&gt; M1;
<a class="code" href="structTooN_1_1Matrix.html#a3aede62f513da27e6f61ae7a972b4f96" title="Construction of static matrices. Values are not initialized.">Matrix</a>&lt;-1,-1,double,RowMajor&gt; M2(nrows, ncols);
</pre></div><p> In this case the precision template argument must be given as it precedes the layout argument </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a722c9c93c228a800dd52d6faa7c9e52e"></a><!-- doxytag: member="TooN::Matrix::Matrix" ref="a722c9c93c228a800dd52d6faa7c9e52e" args="(Precision *data, int rows, int cols, int rowstride, int colstride, Internal::Slicing)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTooN_1_1Matrix.html">Matrix</a> </td>
          <td>(</td>
          <td class="paramtype">Precision *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rowstride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colstride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTooN_1_1Internal_1_1Slicing.html">Internal::Slicing</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Advanced construction of dynamically sized slice matrices. </p>
<p>Internal constructor used by GenericMBase::slice(...). </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad9e754c85d19943cf4c206139972f0fc"></a><!-- doxytag: member="TooN::Matrix::operator()" ref="ad9e754c85d19943cf4c206139972f0fc" args="(int r, int c) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double&amp; operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access an element from the matrix. </p>
<p>The index starts at zero, i.e. the top-left element is m(0, 0). </p>
<div class="fragment"><pre class="fragment">        <span class="keywordtype">double</span> d[2][3] = {{1, 2, 3}, {4, 5, 6}};
        Matrix&lt;2,3&gt; m(d);
        <span class="keywordtype">double</span> e = m(1,2);     <span class="comment">// now e = 6.0;</span>
</pre></div> 
</div>
</div>
<a class="anchor" id="a1fd155aa666835b5c154e3a9add6b1eb"></a><!-- doxytag: member="TooN::Matrix::operator[]" ref="a1fd155aa666835b5c154e3a9add6b1eb" args="(const std::pair&lt; int, int &gt; &amp;row_col) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double&amp; operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; int, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_col</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access an element from the matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">row_col</td><td><code>row_col.first</code> holds the row, <code>row_col.second</code> holds the column. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99e08a9711750afc9fd6811c75e44d62"></a><!-- doxytag: member="TooN::Matrix::operator()" ref="a99e08a9711750afc9fd6811c75e44d62" args="(int r, int c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double&amp; operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access an element from the matrix. </p>
<p>This can be used as either an r-value or an l-value. The index starts at zero, i.e. the top-left element is m(0, 0). </p>
<div class="fragment"><pre class="fragment">        <span class="keywordtype">double</span> d[2][3] = {{1, 2, 3}, {4, 5, 6}};
        Matrix&lt;2,3&gt; m(d);
        m(1,2) = 8;     <span class="comment">// now d = [1 2 3]</span>
                      <span class="comment">//         [4 5 8]</span>
</pre></div> 
</div>
</div>
<a class="anchor" id="a3ac48ce8528ce00c55fe678ce40216e9"></a><!-- doxytag: member="TooN::Matrix::operator[]" ref="a3ac48ce8528ce00c55fe678ce40216e9" args="(int r) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structTooN_1_1Vector.html">Vector</a>&amp; operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access a row from the matrix. </p>
<p>This can be used either as an r-value or an l-value. The index starts at zero, i.e. the first row is m[0]. To extract a column from a matrix, apply [] to the transpose of the matrix (see example). This can be used either as an r-value or an l-value. The index starts at zero, i.e. the first row (or column) is m[0]. </p>
<div class="fragment"><pre class="fragment">        <span class="keywordtype">double</span> d[2][3] = {{1, 2, 3}, {4, 5, 6}};
        Matrix&lt;2,3&gt; m(d);
        Vector&lt;3&gt; v = m[1];       <span class="comment">// now v = [4 5 6];</span>
        Vector&lt;2&gt; v2 = m.T()[0];  <span class="comment">// now v2 = [1 4];</span>
</pre></div> 
</div>
</div>
<a class="anchor" id="a80b44795c876c2392f48496486fd1a4b"></a><!-- doxytag: member="TooN::Matrix::operator[]" ref="a80b44795c876c2392f48496486fd1a4b" args="(int r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTooN_1_1Vector.html">Vector</a>&amp; operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Access a row from the matrix. </p>
<p>This can be used either as an r-value or an l-value. The index starts at zero, i.e. the first row is m[0]. To extract a column from a matrix, apply [] to the transpose of the matrix (see example). This can be used either as an r-value or an l-value. The index starts at zero, i.e. the first row (or column) is m[0]. </p>
<div class="fragment"><pre class="fragment">        <span class="keywordtype">double</span> d[2][3] = {{1, 2, 3}, {4, 5, 6}};
        Matrix&lt;2,3&gt; m(d);
        Zero(m[0]);   <span class="comment">// set the first row to zero</span>
        Vector&lt;2&gt; v = 8,9;
        m.T()[1] = v; <span class="comment">// now m = [0 8 0]</span>
                    <span class="comment">//         [4 9 6]</span>
</pre></div> 
</div>
</div>
<a class="anchor" id="a5de36a6a2dd9d3b3c88cf04337e0dcf0"></a><!-- doxytag: member="TooN::Matrix::T" ref="a5de36a6a2dd9d3b3c88cf04337e0dcf0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt;Cols, Rows&gt;&amp; T </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The transpose of the matrix. </p>
<p>This is a very fast operation--it simply reinterprets a row-major matrix as column-major or vice-versa. This can be used as an l-value. </p>
<div class="fragment"><pre class="fragment">        <span class="keywordtype">double</span> d[2][3] = {{1, 2, 3}, {4, 5, 6}};
        Matrix&lt;2,3&gt; m(d);
        Zero(m[0]);   <span class="comment">// set the first row to zero</span>
        Vector&lt;2&gt; v = 8,9;
        m.T()[1] = v; <span class="comment">// now m = [0 8 0]</span>
                    <span class="comment">//         [4 9 6]</span>
</pre></div> 
<p>Referenced by <a class="el" href="classTooN_1_1WLS.html#af2f3319c456059c6f370473566f8be94">WLS&lt; Size, Precision &gt;::add_mJ()</a>, <a class="el" href="classTooN_1_1WLS.html#a8bd93fca6110ef83b5eacbe9695a5b8f">WLS&lt; Size, Precision &gt;::add_mJ_rows()</a>, <a class="el" href="classTooN_1_1WLS.html#a9d34ef011dea62a6a1d1e5fd8c69ef3e">WLS&lt; Size, Precision &gt;::add_sparse_mJ_rows()</a>, <a class="el" href="classTooN_1_1SIM3.html#a0b79e57eb1656c2faff99d636294e4ac">SIM3&lt; Precision &gt;::adjoint()</a>, <a class="el" href="classTooN_1_1SE3.html#a65a7243620d46edf6c61d032386781a5">SE3&lt; Precision &gt;::adjoint()</a>, <a class="el" href="classTooN_1_1SymEigen.html#abb184ff08034531a9816629905dcaba0">SymEigen&lt; Size, Precision &gt;::backsub()</a>, <a class="el" href="classTooN_1_1SymEigen.html#ac3fe99c85f56283dd01369969bf7f4fb">SymEigen&lt; Size, Precision &gt;::get_isqrtm()</a>, <a class="el" href="classTooN_1_1SymEigen.html#a718835dc50234a684aefa81fa098b7f6">SymEigen&lt; Size, Precision &gt;::get_pinv()</a>, <a class="el" href="classTooN_1_1GR__SVD.html#af4f116a7c9a17c1d69106657581de215">GR_SVD&lt; M, N, Precision, WANT_U, WANT_V &gt;::get_pinv()</a>, <a class="el" href="classTooN_1_1SymEigen.html#a85f0e1d2a1ff13dbff6ec0bf6302832c">SymEigen&lt; Size, Precision &gt;::get_sqrtm()</a>, <a class="el" href="classTooN_1_1GR__SVD.html#a40baf67ed366df43a526df2ab9f2e708">GR_SVD&lt; M, N, Precision, WANT_U, WANT_V &gt;::reorder()</a>, <a class="el" href="classTooN_1_1SO3.html#ab571affe7da3d2646dc58cbbcc91e448">SO3&lt; P &gt;::SO3()</a>, <a class="el" href="classTooN_1_1SIM3.html#ab484209a5cb3c8d3e9c0334447528903">SIM3&lt; Precision &gt;::trinvadjoint()</a>, and <a class="el" href="classTooN_1_1SE3.html#aed222197aa4b26ca4dfc76444f8165da">SE3&lt; Precision &gt;::trinvadjoint()</a>.</p>

</div>
</div>
<a class="anchor" id="a103cfb9adb98ba245872bd6f98b1c211"></a><!-- doxytag: member="TooN::Matrix::T" ref="a103cfb9adb98ba245872bd6f98b1c211" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt;Cols, Rows&gt;&amp; T </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The transpose of the matrix. </p>
<p>This is a very fast operation--it simply reinterprets a row-major matrix as column-major or vice-versa. The result can be used as an l-value. </p>
<div class="fragment"><pre class="fragment">        <span class="keywordtype">double</span> d[2][3] = {{1, 2, 3}, {4, 5, 6}};
        Matrix&lt;2,3&gt; m(d);
        Vector&lt;2&gt; v = 8,9;
        <span class="comment">// Set the first column to v</span>
        m.T()[0] = v; <span class="comment">// now m = [8 2 3]</span>
                    <span class="comment">//         [9 5 6]</span>
</pre></div><p> <b>This means that the semantics of <code>M=M.<a class="el" href="structTooN_1_1Matrix.html#a103cfb9adb98ba245872bd6f98b1c211" title="The transpose of the matrix.">T()</a></code> are broken</b>. In general, it is not necessary to say <code>M=M.<a class="el" href="structTooN_1_1Matrix.html#a103cfb9adb98ba245872bd6f98b1c211" title="The transpose of the matrix.">T()</a></code>, since you can use M.T() for free whenever you need the transpose, but if you do need to, you have to use the Tranpose() function defined in <code><a class="el" href="helpers_8h_source.html">helpers.h</a></code>. </p>

</div>
</div>
<a class="anchor" id="a53b254fb71baceda82834745cef2c60b"></a><!-- doxytag: member="TooN::Matrix::slice" ref="a53b254fb71baceda82834745cef2c60b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt;Rsize, Csize&gt;&amp; slice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract a sub-matrix. </p>
<p>The matrix extracted will be begin at element (Rstart, Cstart) and will contain the next Rsize by Csize elements. </p>
<div class="fragment"><pre class="fragment">        <span class="keywordtype">double</span> d[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
        Matrix&lt;3&gt; m(d);
        Extract the top-left 2x2 matrix
        Matrix&lt;2&gt; b = m.slice&lt;0,0,2,2&gt;();  <span class="comment">// b = [1 2]</span>
                                          <span class="comment">//     [4 5]</span>
</pre></div> 
<p>Referenced by <a class="el" href="classTooN_1_1WLS.html#a9d34ef011dea62a6a1d1e5fd8c69ef3e">WLS&lt; Size, Precision &gt;::add_sparse_mJ_rows()</a>, and <a class="el" href="namespaceTooN.html#a14da8c20b43b0bed2f9dc3d76428bc96">TooN::project()</a>.</p>

</div>
</div>
<a class="anchor" id="af7b485aa536050f3d50d846c15543b03"></a><!-- doxytag: member="TooN::Matrix::slice" ref="af7b485aa536050f3d50d846c15543b03" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&lt;Rsize, Csize&gt;&amp; slice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract a sub-matrix. </p>
<p>The matrix extracted will be begin at element (Rstart, Cstart) and will contain the next Rsize by Csize elements. This can be used as either an r-value or an l-value. </p>
<div class="fragment"><pre class="fragment">        <span class="keywordtype">double</span> d[2][3] = {{1, 2, 3}, {4, 5, 6}};
        Matrix&lt;2,3&gt; m(d);
        Zero(m.slice&lt;0,2,2,1&gt;());  <span class="comment">// b = [1 2 0]</span>
                                  <span class="comment">//     [4 5 0]</span>
</pre></div> 
</div>
</div>
<a class="anchor" id="a8e6dd43172fbe373c0e1bd184411a382"></a><!-- doxytag: member="TooN::Matrix::slice" ref="a8e6dd43172fbe373c0e1bd184411a382" args="(int rstart, int cstart, int rsize, int csize) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&amp; slice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>csize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract a sub-matrix with runtime location and size. </p>
<p>The matrix extracted will begin at element (rstart, cstart) and will contain the next rsize by csize elements. </p>
<div class="fragment"><pre class="fragment">        Matrix&lt;&gt; m(3,3);
        Extract the top-left 2x2 matrix
        Matrix&lt;2&gt; b = m.slice(0,0,2,2);
</pre></div> 
</div>
</div>
<a class="anchor" id="a6e17789077ce550be82c9c073260f2b8"></a><!-- doxytag: member="TooN::Matrix::slice" ref="a6e17789077ce550be82c9c073260f2b8" args="(int rstart, int cstart, int rsize, int csize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTooN_1_1Matrix.html">Matrix</a>&amp; slice </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cstart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>csize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Extract a sub-matrix with runtime location and size, which can be used as an l-value. </p>
<p>The matrix extracted will be begin at element (rstart, cstart) and will contain the next rsize by csize elements. </p>
<div class="fragment"><pre class="fragment">        Matrix&lt;&gt; m(3,3);
        Zero(m.slice(0,0,2,2));
</pre></div> 
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Wed Feb 8 2012 21:52:00 for TooN by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
